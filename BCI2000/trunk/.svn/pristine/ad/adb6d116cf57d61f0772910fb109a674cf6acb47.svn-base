////////////////////////////////////////////////////////////////////////////////
// Authors: Robbie@DESKTOP-U5JGQCU.wucon.wustl.edu
// Description: BrainFlowADC implementation
////////////////////////////////////////////////////////////////////////////////
#include "BrainFlowADC.h"

#include "BCIStream.h"

// Make the source filter known to the framework.
RegisterFilter( BrainFlowADC, 1 ); // ADC filters must be registered at location "1" in order to work.

BrainFlowADC::BrainFlowADC()
{
}

BrainFlowADC::~BrainFlowADC()
{
    delete mpBoard;
}

void
BrainFlowADC::OnPublish()
{
 // Declare any parameters that the filter needs....

  BEGIN_PARAMETER_DEFINITIONS

    "Source:Signal%20Properties int SourceCh= auto "
       "% // number of digitized and stored channels",

     "Source:Signal%20Properties matrix RecordingChannels= {Record:} {EEG EMG ECG EOG EXG PPG EDA Accel Analog Gyro Other Temp Resistance Magnetometer} 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 "
      "// Channels to have data recorded",

    "Source:Signal%20Properties int SampleBlockSize= 20 20 1 % "
       "// number of samples transmitted at a time",

    "Source:Signal%20Properties float SamplingRate= auto " 
       "// sample rate",

    "Source:Signal%20Properties list SourceChGain= 1 auto "
       " // physical units per raw A/D unit",

    "Source:Signal%20Properties list SourceChOffset= 1 auto "
       " // raw A/D offset to subtract, typically 0",

    "Source:Signal%20Properties list ChannelNames= 1 auto "
       " // names of amplifier channels",

     "Source:Signal%20Properties int BoardID= 1 auto 0 49 "
     " // Board to be Used: 0 CYTON_BOARD, 1 GANGLION_BOARD, 2 CYTON_DAISY_BOARD, 3 GALEA_BOARD, 4 GANGLION_WIFI_BOARD, 5 CYTON_WIFI_BOARD, 6 CYTON_DAISY_WIFI_BOARD, 7 BRAINBIT_BOARD, 8 UNICORN_BOARD, 9 CALLIBRI_EEG_BOARD, 10 CALLIBRI_EMG_BOARD, 11 CALLIBRI_ECG_BOARD, 12 NOTION_1_BOARD, 13 NOTION_2_BOARD, 14 GFORCE_PRO_BOARD, 15 FREEEEG32_BOARD, 16 BRAINBIT_BLED_BOARD, 17 GFORCE_DUAL_BOARD, 18 GALEA_SERIAL_BOARD, 19 MUSE_S_BLED_BOARD, 20 MUSE_2_BLED_BOARD, 21 CROWN_BOARD, 22 ANT_NEURO_EE_410_BOARD, 23 ANT_NEURO_EE_411_BOARD, 24 ANT_NEURO_EE_430_BOARD, 25 ANT_NEURO_EE_211_BOARD, 26 ANT_NEURO_EE_212_BOARD, 27 ANT_NEURO_EE_213_BOARD, 28 ANT_NEURO_EE_214_BOARD, 29 ANT_NEURO_EE_215_BOARD, 30 ANT_NEURO_EE_221_BOARD, 31 ANT_NEURO_EE_222_BOARD, 32 ANT_NEURO_EE_223_BOARD, 33 ANT_NEURO_EE_224_BOARD, 34 ANT_NEURO_EE_225_BOARD, 35 ENOPHONE_BOARD, 36 MUSE_2_BOARD, 37 MUSE_S_BOARD, 38 BRAINALIVE_BOARD, 39 MUSE_2016_BOARD, 40 MUSE_2016_BLED_BOARD, 41 EXPLORE_4_CHAN_BOARD, 42 EXPLORE_8_CHAN_BOARD, 43 GANGLION_NATIVE_BOARD, 44 EMOTIBIT_BOARD, 45 GALEA_BOARD_V4, 46 GALEA_SERIAL_BOARD_V4, 47 NTL_WIFI_BOARD, 48 ANT_NEURO_EE_511_BOARD, 49 FREEEEG128_BOARD (enumeration)",

     "Source:Signal%20Properties string COM= auto % % % "
     " // COM Port Device is Connected to (Leave as auto if not applicable)",

     "Source:Signal%20Properties string MAC= auto % % % "
     " // Device MAC Address (Leave as auto if not applicable)",

     "Source:Signal%20Properties string IPPort= auto % % % "
     " // Leave as auto if not applicable",

     "Source:Signal%20Properties string SerialNumber= auto % % % "
     " // Device Serial Number (Leave as auto if not applicable)",
  END_PARAMETER_DEFINITIONS

  // ...and likewise any state variables.

  BEGIN_STREAM_DEFINITIONS
    "BrainFlowADCSyncTriggers 8 0", // <name> <bit width> <initial value>
  END_STREAM_DEFINITIONS

  BEGIN_EVENT_DEFINITIONS
    "BrainFlowADCAsyncTriggers 8 0", // <name> <bit width> <initial value>
  END_EVENT_DEFINITIONS

}

void
BrainFlowADC::OnAutoConfig()
{
    //Board ID
    int boardID = Parameter("BoardID").ToNumber();
    if (boardID >= 12)
    {
        ++boardID;
    }
    if (boardID >= 15)
    {
        ++boardID;
    }
    if (boardID >= 43)
    {
        ++boardID;
    }
    mBoardID = static_cast<BoardIds>(boardID);
    if (!(BoardIds::FIRST <= mBoardID && mBoardID <= BoardIds::LAST))
    {
        bcierr << "Invalid board number";
    }
    //Sampling Rate
    if  (Parameter("SamplingRate") != "auto") {
        bcierr << "Sampling rate will be set depending on board ID. Please leave as auto.";
    }
    double samplingRate = mpBoard->get_sampling_rate(static_cast<int>(mBoardID));
    Parameter("SamplingRate") << samplingRate << "Hz";

    //Sample Block Size
    if (Parameter("SampleBlockSize").ToString() == "auto") { bcierr << "Please enter an integer for sample block size"; }
    mSampleBlockSize = Parameter("SampleBlockSize");

   //channels
    mChannels.clear();
    std::vector<std::string> channelNames;
    std::vector<int> recList;
    if (Parameter("SourceCh") != "auto")
    {
        bcierr << "SourceCh will be calculated based off entries in RecordingChannels. Please leave as auto";
    }
    for (int i = 0; i < 14; ++i) {
        if (Parameter("RecordingChannels")(0,i))
        {
            recList.push_back(i);
        }
    }
    for (auto i : recList)
    {
        std::vector<int> tempChannelIndicies = ChannelIndices(static_cast<int>(mBoardID), i+1);
        mChannels.reserve(mChannels.size() + tempChannelIndicies.size());
        mChannels.insert(mChannels.end(), tempChannelIndicies.begin(), tempChannelIndicies.end());
        if (i == 0)
        {
        std::vector<std::string> tempEEGNames = BoardShim::get_eeg_names(static_cast<int>(mBoardID));
        channelNames.insert(channelNames.end(), tempEEGNames.begin(),tempEEGNames.end());
        }
        else
        {
            for (int k = 0; k < tempChannelIndicies.size(); ++k)
            {
                channelNames.push_back(ChannelTypeName(i+1) + "_" + std::to_string(k));
            }
        }
    }
    mNumberOfSignalChannels = mChannels.size();
    Parameter("SourceCh") = mNumberOfSignalChannels;
    if (Parameter("ChannelNames") != "auto" && ActualParameter("ChannelNames")->NumValues() != mNumberOfSignalChannels)
    {
        bcierr << "The number of entered channel names are not consistent with the channels recording data (" << mNumberOfSignalChannels << " collecting data, " << ActualParameter("ChannelNames")->NumValues() << " specified";
    }
    if (Parameter("SourceChGain") != "auto" && ActualParameter("SourceChGain")->NumValues() != mNumberOfSignalChannels)
    {
        bcierr << "The number of entered channel gain values are not consistent with the channels recording data (" << mNumberOfSignalChannels << " collecting data, " << ActualParameter("SourceChGain")->NumValues() << " specified";
    }
    if (Parameter("SourceChOffset") != "auto" && ActualParameter("SourceChOffset")->NumValues() != mNumberOfSignalChannels)
    {
        bcierr << "The number of entered channel offset values are not consistent with the channels recording data (" << mNumberOfSignalChannels << " collecting data, " << ActualParameter("SourceChOffset")->NumValues() << " specified";
    }

    Parameter("ChannelNames")->SetNumValues(mNumberOfSignalChannels);
    Parameter("SourceChGain")->SetNumValues(mNumberOfSignalChannels);
    Parameter("SourceChOffset")->SetNumValues(mNumberOfSignalChannels);

    for (int i = 0; i < mNumberOfSignalChannels; ++i) {
        Parameter("ChannelNames")(i) = channelNames.at(i);
    }

    for (int i = 0; i < mNumberOfSignalChannels; ++i)
    {
        double gainFactor = 1.0;
        Parameter("SourceChGain")(i) << gainFactor << "muV";
        Parameter("SourceChOffset")(i) = 0;
    }
}

void
BrainFlowADC::OnPreflight( SignalProperties& Output ) const
{
  Parameter("COM");
  Parameter("BoardID");
  Parameter("SamplingRate");
  Parameter("SampleBlockSize");
  Parameter("IPPort");
  Parameter("SerialNumber");
  if (Parameter("MAC").ToString().length() != 18 && Parameter("MAC").ToString() != "auto")
  {
      bcierr << "Invalid MAC Address";
  }
  SignalType sigType = SignalType::float32;

  int samplesPerBlock = Parameter("SampleBlockSize"); //Output.Elements();
  int numberOfSignalChannels = Parameter("SourceCh"); //Output.Channels();

  Output = SignalProperties( numberOfSignalChannels, samplesPerBlock, sigType );
}

void
BrainFlowADC::OnInitialize( const SignalProperties& Output )
{
    //BoardIds
    struct BrainFlowInputParams params;
    BoardShim::get_board_presets(static_cast<int>(mBoardID));
    if (Parameter("MAC").ToString() != "auto")
    {
        params.mac_address = Parameter("MAC").ToString();
    }
    params.master_board = static_cast<int>(mBoardID);
    if (Parameter("COM").ToString() != "auto")
    {
        params.serial_port = Parameter("COM").ToString();
    }
    if (Parameter("IPPort").ToString() != "auto")
    {
        params.ip_port = Parameter("IPPort").ToNumber();
    }
    if (Parameter("SerialNumber").ToString() != "auto")
    {
        params.serial_number = Parameter("SerialNumber").ToString();
    }
    delete mpBoard;
    mpBoard = new BoardShim(static_cast<int>(mBoardID), params);
    mpBoard->prepare_session();
    if (!mpBoard->is_prepared())
    {
        bcierr << "Initialization failed";
    }
    mpBoard->start_stream();
}

void
BrainFlowADC::OnStartAcquisition()
{
    mpBoard->get_board_data(0);
}

void
BrainFlowADC::DoAcquire(GenericSignal& Output)
{
    int k = mpBoard->get_board_data_count()/mpBoard->get_num_rows(static_cast<int>(mBoardID));
    if (mSampleBlockSize > (mData.size()) /mChannels.size()+k) 
    {
        std::this_thread::sleep_for(std::chrono::milliseconds((1000 * (mSampleBlockSize -k- (mData.size()) / mChannels.size()) / (mpBoard->get_sampling_rate(static_cast<int>(mBoardID))))));
    }
    while (mData.size() < mSampleBlockSize * mChannels.size())
    {
        auto tempDataHolder = mpBoard->get_board_data(mSampleBlockSize-mData.size()/ mChannels.size(), 0);
        int numRec = tempDataHolder.get_length() / mpBoard->get_num_rows(static_cast<int>(mBoardID));
        for (int i = 0; i < numRec; ++i)
        {
            for (int j = 0; j < mChannels.size(); ++j)
            {
                mData.push(tempDataHolder.get_address(mChannels[j])[i]);
            }
        }
    }

    for (int sample = 0; sample < mSampleBlockSize; sample++)
    {
        for (int ch = 0; ch < mChannels.size(); ch++)
        {
            Output(ch, sample) = mData.front();
            mData.pop();
        }
    }
}
void
BrainFlowADC::OnStopAcquisition()
{
    mpBoard->stop_stream();
    if (mpBoard->is_prepared())
    {
        mpBoard->release_session();
        bciwarn << "Streaming session released";
    }
}
//EEG EMG ECG EOG EXG PPG EDA Accel Analog Gyro Other Temp Resistance Magnetometer
//Helper function to return the type of data the integer N corresponds to
std::string
BrainFlowADC::ChannelTypeName(int N)
{
    switch (N)
    {
    case 2:
        return "EMG";
    case 3:
        return "ECG";
    case 4:
        return "EOG";
    case 5:
        return "EXG";
    case 6:
        return "PPG";
    case 7:
        return "EDA";
    case 8:
        return "Accel";
    case 9:
        return "Analog";
    case 10:
        return "Gyro";
    case 11:
        return "Other";
    case 12:
        return "Temp";
    case 13:
        return "Resistance";
    case 14:
        return "Magnetometer";
    }
    bcierr << "Unknown channel type: " << N;
    return "??";
}
//EEG EMG ECG EOG EXG PPG EDA Accel Analog Gyro Other Temp Resistance Magnetometer
//helper function to return a list of the indexes corresponding to the channels recording a certain type of data, indicated by N
std::vector<int>
BrainFlowADC::ChannelIndices(int id, int N)
{
    switch (N)
    {
    case 1:
        return BoardShim::get_eeg_channels(id);
    case 2:
        return BoardShim::get_emg_channels(id);
    case 3:
        return BoardShim::get_ecg_channels(id);
    case 4:
        return BoardShim::get_eog_channels(id);
    case 5:
        return BoardShim::get_exg_channels(id);
    case 6:
        return BoardShim::get_ppg_channels(id);
    case 7:
        return BoardShim::get_eda_channels(id);
    case 8:
        return BoardShim::get_accel_channels(id);
    case 9:
        return BoardShim::get_analog_channels(id);
    case 10:
        return BoardShim::get_gyro_channels(id);
    case 11:
        return BoardShim::get_other_channels(id);
    case 12:
        return BoardShim::get_temperature_channels(id);
    case 13:
        return BoardShim::get_resistance_channels(id);
    case 14:
        return BoardShim::get_magnetometer_channels(id);
    }
    bcierr << "Unknown channel kind";
    return std::vector<int>();
}
