////////////////////////////////////////////////////////////////////////////////
// $Id$
// Author: juergen.mellinger@uni-tuebingen.de
// Description: A base class that implements functionality common to all
//              file writer classes that output into a file.
//
// $BEGIN_BCI2000_LICENSE$
//
// This file is part of BCI2000, a platform for real-time bio-signal research.
// [ Copyright (C) 2000-2023: BCI2000 team and many external contributors ]
//
// BCI2000 is free software: you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the Free Software
// Foundation, either version 3 of the License, or (at your option) any later
// version.
//
// BCI2000 is distributed in the hope that it will be useful, but
//                         WITHOUT ANY WARRANTY
// - without even the implied warranty of MERCHANTABILITY or FITNESS FOR
// A PARTICULAR PURPOSE.  See the GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along with
// this program.  If not, see <http://www.gnu.org/licenses/>.
//
// $END_BCI2000_LICENSE$
////////////////////////////////////////////////////////////////////////////////
#include "FileWriterBase.h"

#include "BCIStream.h"
#include "ClassName.h"
#include "FileUtils.h"
#include "RunManager.h"
#include "BCIEvent.h"

#include <fstream>
#include <iomanip>
#include <iostream>

static const char *cBciParameterExtension = ".prm";

static std::string ParameterFile(const std::string &inDataFile)
{
    return FileUtils::ExtractDirectory(inDataFile) + FileUtils::ExtractBase(inDataFile) + cBciParameterExtension;
}

FileWriterBase::FileWriterBase()
    : mpOutputFormatFactory(nullptr),
      mFilePart(1)
{
}

FileWriterBase::~FileWriterBase()
{
    Halt();
    delete mpOutputFormatFactory;
}

void FileWriterBase::Publish()
{
    if (!mpOutputFormat.get())
        mpOutputFormat.reset(mpOutputFormatFactory->Create());
    mpOutputFormat->Publish();

    std::string ext = mpOutputFormat->DataFileExtension();
    size_t i = 0;
    while (i < ext.length() && ::ispunct(ext[i]))
        ++i;
    std::string formatName = ext.substr(i);

    if (Parameters->Exists("/FileFormat"))
        Parameters->Delete("/FileFormat");
    std::string def = "Storage string /FileFormat= " + formatName + " % % % // format of data file (readonly)";
    BEGIN_PARAMETER_DEFINITIONS
      def.c_str(),
    END_PARAMETER_DEFINITIONS

    if (OptionalParameter("SavePrmFile") != 0)
    {
        BEGIN_PARAMETER_DEFINITIONS
            "Storage:Documentation int SavePrmFile= 0 1 0 1 "
               "// save additional parameter file for each run (0=no, 1=yes) (boolean)",
        END_PARAMETER_DEFINITIONS
    }

    BEGIN_PARAMETER_DEFINITIONS
        "Storage:Documentation string /StorageTime= % % % % "
          "// time of beginning of data storage",

        "Storage:FileSplitting string FileSplittingCondition= % % % % "
          "// when to split files, e.g. \"1:25:00\" or \"1.5GB\"",
    END_PARAMETER_DEFINITIONS

    BEGIN_PARAMETER_DEFINITIONS
        "Storage:Output%20Files string PrimaryOutputChannels= * % % % "
          "// list of channels stored into the primary output file: Channel names may contain * and ? wildcards, "
          " and character ranges enclosed in []; wildcard patterns may be negated by prepending an exclamation mark. "
          " Ranges of channels may be specified using : or - to separate begin from end.",

        "Storage:Output%20Files matrix SecondaryOutputFiles= 0 [name channels decimation] % % % "
          "// specify names (infixes) for secondary output files, with channel list and decimation",
    END_PARAMETER_DEFINITIONS

    BEGIN_EVENT_DEFINITIONS
        "FilePart 32 1",
    END_EVENT_DEFINITIONS
}

void FileWriterBase::AutoConfig(const SignalProperties& Input)
{
    mOutputFileStreams.clear();

    OutputFileStream::Properties properties;
    std::string PrimaryOutputChannels = Parameter("PrimaryOutputChannels");
    properties.channels = IndexList(PrimaryOutputChannels, Input.ChannelLabels());
    if (!properties.channels.Errors().empty())
        bcierr << "Invalid PrimaryOutputChannels: " << PrimaryOutputChannels << ": " << properties.channels.Errors();
    else if (properties.channels.Empty() && !Input.IsEmpty())
        bciwarn << "PrimaryOutputChannels \"" << PrimaryOutputChannels << "\" does not match any channel";
    properties.decimation = 1;
    mOutputFileStreams.push_back(std::make_unique<OutputFileStream>(properties, mpOutputFormat));

    std::set<std::string> names;
    ParamRef SecondaryOutputFiles = Parameter("SecondaryOutputFiles");
    for (int row = 0; row < SecondaryOutputFiles->NumRows(); ++row) {
        properties = {};
        properties.name = SecondaryOutputFiles(row, "name").ToString();
        names.insert(properties.name);
        std::string channels = SecondaryOutputFiles(row, "channels");
        properties.channels = IndexList(channels, Input.ChannelLabels());
        if (!properties.channels.Errors().empty())
            bcierr << "Invalid channels entry in SecondaryOutputFiles: " << channels << ": " << properties.channels.Errors();
        else if (properties.channels.Empty() && !Input.IsEmpty())
            bciwarn << "SecondaryOutputFiles(" << row << ", channels) is \"" << PrimaryOutputChannels << "\", does not match any channel";
        properties.decimation = SecondaryOutputFiles(row, "decimation");
        if (properties.decimation < 1)
            properties.decimation = 1;
        if (Input.Elements() % properties.decimation != 0)
            bcierr << "SecondaryOutputFiles: decimation must be a divisor of SampleBlockSize";
        std::shared_ptr<GenericOutputFormat> pFormat(mpOutputFormatFactory->Create());
        mOutputFileStreams.push_back(std::make_unique<OutputFileStream>(properties, pFormat));
    }
    if (names.size() != SecondaryOutputFiles->NumRows())
        bcierr << "SecondaryOutputFiles: multiple rows have the same names";
    if (names.find("") != names.end())
        bcierr << "SecondaryOutputFiles: must specifiy names";
}

void FileWriterBase::Preflight(const SignalProperties &Input, SignalProperties &Output) const
{
    for (const auto& p : mOutputFileStreams)
        p->Preflight(Input);

    // Test file splitting condition.
    std::string error = FileSplittingCondition().Compile(Parameter("FileSplittingCondition")).Error();
    if (!error.empty())
        bcierr << "Invalid FileSplittingCondition: " << error;

    // State availability.
    State("SourceTime");

    // File accessibility.
    std::string dataFile = RunManager()->CurrentRun();
    if (OptionalParameter("SavePrmFile") == 1)
    {
        std::string paramFile = ParameterFile(dataFile);
        if (FileUtils::Exists(paramFile))
            bcierr << "Parameter file \"" << paramFile << "\" already exists, "
                   << "will not be touched.";
        else if (!FileUtils::IsWritableLocation(paramFile))
            bcierr << "Cannot write to file location \"" << paramFile << "\"";
    }

    if (!std::string(Parameter("StorageTime")).empty())
        bciout << "The StorageTime parameter will be overwritten with the"
               << " recording's actual date and time";

    Output = SignalProperties(0, 0);
}

void FileWriterBase::Initialize(const SignalProperties &Input, const SignalProperties & /*Output*/)
{
    mFileSplittingCondition.Compile(Parameter("FileSplittingCondition"));
    for (const auto& p : mOutputFileStreams)
        p->Initialize(Input, Statevector->Length());
}

void FileWriterBase::BeginFile()
{
    // This will be called from a separate thread, so we need to set up context explicitly.
    ErrorContext("BeginFile", this);
    time_t now = ::time(nullptr);
    struct tm* timeinfo = ::localtime(&now);
    char buffer[20];
    ::strftime(buffer, sizeof(buffer), "%Y-%m-%dT%H:%M:%S", timeinfo);

    std::lock_guard<std::mutex> lock(mMutex);
    mParameters("/StorageTime") = buffer;

    for (auto& p : mOutputFileStreams)
        p->BeginFile(RunManager()->CurrentFile(), mParameters, mStates);
    ErrorContext("");
}

void FileWriterBase::EndFile()
{
    // This will be called from a separate thread, so we need to set up context explicitly.
    ErrorContext("EndFile", this);
    for (auto& p : mOutputFileStreams)
        p->EndFile();
    ErrorContext("");
}

void FileWriterBase::StartRun()
{
    if (OptionalParameter("SavePrmFile") == 1)
    {
        std::string paramFile = ParameterFile(RunManager()->CurrentRun());
        std::ofstream file(paramFile);
        if (!(file << *Parameters << std::flush))
            bcierr << "Error writing parameters to file " << paramFile;
    }

    std::unique_lock<std::mutex> lock(mMutex);
    mParameters = *Parameters; // create a copy that can be used inside the writer thread
    mStates = *States; // dito
    lock.unlock();

    mFilePart = 1;
    BeginFile();
    mQueue.Clear();
    Thread::Start();
}

void FileWriterBase::StopRun()
{
    Thread::Terminate();
    if (!mQueue.Empty())
        bcierr << "Nonempty buffering queue";
    EndFile();
}

void FileWriterBase::Halt()
{
    Thread::Terminate();
}

void FileWriterBase::Write(const GenericSignal &Signal, const StateVector &Statevector)
{
    mQueue.Produce(std::make_pair(Signal, Statevector));
}

int FileWriterBase::OnExecute()
{
    std::string fileName = RunManager()->CurrentRun();
    TimeUtils::Time startTime = TimeUtils::SystemTimeUTC();

    Queue::Consumable c;
    while (mOutputFileStreams[0]->IsGood() && (c = mQueue.AwaitConsumption(Time::Forever())))
    {   // When a data block with incremented FilePart event arrives, begin a new file.
        // By interposing a FilePart event, we allow other parts of the system to
        // begin new files in a synchronized manner.
        // To catch all changes in the FilePart event, evaluate it at the last sample
        // of the state vector.
        Assert(c->second.Samples() > 0);
        int lastSample = c->second.Samples() - 1;
        int nextFilePart = c->second.StateValue("FilePart", lastSample);

        if (nextFilePart > mFilePart)
        {
            // Close the current file.
            EndFile();
            mFilePart = nextFilePart;
            startTime = TimeUtils::SystemTimeUTC();
            // Ask the RunManager to create the next file.
            fileName = RunManager()->BeginNextFilePart();
            // Set everything up for the new file, and write the header.
            BeginFile();
        }

        int64_t pos1 = mOutputFileStreams[0]->Position();
        for (auto& p : mOutputFileStreams)
            p->Write(c->first, c->second);
        int64_t blockSize = mOutputFileStreams[0]->Position() - pos1;
        for (auto& p : mOutputFileStreams)
            p->Flush();

        TimeUtils::TimeInterval timeElapsed = TimeUtils::SystemTimeUTC() - startTime;
        // When evaluating file size, we need to take account for two blocks of delay
        // between broadcasting an event, and its arrival at the write queue.
        int64_t fileSize = mOutputFileStreams[0]->Position() + 2 * blockSize;
        if (mFileSplittingCondition.Evaluate(timeElapsed, fileSize))
        {
            // When the file splitting condition evaluates to true, do not act directly but
            // broadcast an increment of the FilePart event.
            if (!mOutputFileStreams[0]->IsGood())
                bcierr << "Error writing to file \"" << fileName << "\"";
            // When sending the event, make sure to set it at a block boundary.
            // This is achieved by associating it with the current block's SourceTime stamp.
            PrecisionTime timeStamp = c->second.StateValue("SourceTime");
            BCIEvent(timeStamp) << "FilePart " << mFilePart + 1;
        }
    }
    while ((c = mQueue.Consume())) {
        for (auto& p : mOutputFileStreams)
            p->Write(c->first, c->second);
    }
    for (auto& p : mOutputFileStreams) {
        p->Flush();
        if (!p->IsGood())
            bcierr << "Error writing to file \"" << p->FileName() << "\"";
    }
    return 0;
}
