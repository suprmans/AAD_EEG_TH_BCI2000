<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Contributions:SerialWidgetADC - BCI2000 Help</title>
<link rel='shortcut icon' href='../../rsrc/favicon.ico' />
<style type='text/css'>
html { font-size:95%; font-family:arial,helvetica,sans-serif }
.printfooter { display:none }
#tocmain { font-size:81%; font-weight:bold; color:grey; background-color:white; border:1px solid black; padding:1em; z-index:10; position:fixed; left:-1px; top:-1px; width:150px; }
#tocmain a { color:black; text-decoration:none }
#tocmain ul { margin:0 0 0 0.4em; padding:0.1em 0 0 0.1em; list-style-position:outside; list-style-type:disc }
#tocmain li { text-indent:0; margin:0 0 0 1em; padding: 0 0 0 0 }
#tocmain p { margin:0; padding:0.1em 0 0 0.1em }
#tocmain .toc1 { margin-left:1.25em; }
#tocmain .toc2 { margin-left:2.25em; }
#tocmain .toc3 { margin-left:3.25em; }
#article { font-size:91%; position:absolute; left:200px; right:0; padding:1em; margin:0 }
</style>
</head>
<body>
 <div id='tocmain'>
 <a href='Main_Page.html'><img src='../../rsrc/bci2000logo.svg' alt='[Main Page]' /></a> <hr class="sep" /><p class="toc0"><a href="User_Tutorial%253ABCI2000_Tour.html">GettingStarted</a></p><ul></ul><p class="toc0"><a href="User_Reference%253AContents.html">User Manual</a></p><ul></ul><p class="toc0"><a href="Technical_Reference%253AContents.html">Technical Reference</a></p><ul></ul><p class="toc0"><a href="Programming_Reference%253AContents.html">Programming Manual</a></p><ul></ul><p class="toc0"><a href="Contributions%253AContents.html">Contributions</a></p><ul><li class="toc1"><a href="Contributions%253AADCs.html">Data Acquisition</a></li><li class="toc1"><a href="Contributions%253AFileWriters.html">File Formats</a></li><li class="toc1"><a href="Contributions%253ASignalProcessing.html">Signal Processing</a></li><li class="toc1"><a href="Contributions%253AApplications.html">Applications</a></li><li class="toc1"><a href="Contributions%253ATools.html">Tools</a></li></ul><hr class="sep" /><p class="toc0"><a href="BCI2000_Glossary.html">BCI2000 Glossary</a></p> </div>
 <div id='article'>
 <h1 class = "pagetitle">SerialWidgetADC</h1>
 <p class = "subtitle">Contributions</p>
 <hr class = "sep" />
 <div id="mw-content-text" class="mw-body-content mw-content-ltr" lang="en" dir="ltr"><div class="mw-parser-output"><div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="Contributions%253ASerialWidgetADC.html#Synopsis"><span class="tocnumber">1</span> <span class="toctext">Synopsis</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="Contributions%253ASerialWidgetADC.html#Location"><span class="tocnumber">2</span> <span class="toctext">Location</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="Contributions%253ASerialWidgetADC.html#Versioning"><span class="tocnumber">3</span> <span class="toctext">Versioning</span></a>
<ul>
<li class="toclevel-2 tocsection-4"><a href="Contributions%253ASerialWidgetADC.html#Authors"><span class="tocnumber">3.1</span> <span class="toctext">Authors</span></a></li>
<li class="toclevel-2 tocsection-5"><a href="Contributions%253ASerialWidgetADC.html#Version_History"><span class="tocnumber">3.2</span> <span class="toctext">Version History</span></a></li>
<li class="toclevel-2 tocsection-6"><a href="Contributions%253ASerialWidgetADC.html#Source_Code_Revisions"><span class="tocnumber">3.3</span> <span class="toctext">Source Code Revisions</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-7"><a href="Contributions%253ASerialWidgetADC.html#Functional_Description"><span class="tocnumber">4</span> <span class="toctext">Functional Description</span></a></li>
<li class="toclevel-1 tocsection-8"><a href="Contributions%253ASerialWidgetADC.html#Parameters"><span class="tocnumber">5</span> <span class="toctext">Parameters</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="Contributions%253ASerialWidgetADC.html#SourceChPins"><span class="tocnumber">5.1</span> <span class="toctext">SourceChPins</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="Contributions%253ASerialWidgetADC.html#States"><span class="tocnumber">6</span> <span class="toctext">States</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="Contributions%253ASerialWidgetADC.html#Widget_Programming"><span class="tocnumber">7</span> <span class="toctext">Widget Programming</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="Contributions%253ASerialWidgetADC.html#Widget_Timing"><span class="tocnumber">8</span> <span class="toctext">Widget Timing</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="Contributions%253ASerialWidgetADC.html#See_also"><span class="tocnumber">9</span> <span class="toctext">See also</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Synopsis">Synopsis</span></h2>
<p>An ADC that allows signals to be acquired from programmable serial-port devices such as the Arduino, Teensy, Pico, etc.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Location">Location</span></h2>
<p><a rel="nofollow" class="external free" href="http://www.bci2000.org/svn/trunk/src/contrib/SignalSource/SerialWidget">http://www.bci2000.org/svn/trunk/src/contrib/SignalSource/SerialWidget</a>
</p><p><br />
</p>
<h2><span class="mw-headline" id="Versioning">Versioning</span></h2>
<h3><span class="mw-headline" id="Authors">Authors</span></h3>
<p>Jeremy Hill (hill@neurotechcenter.org)
</p>
<h3><span class="mw-headline" id="Version_History">Version History</span></h3>
<ul><li>2023-09-22: Initial public release</li></ul>
<h3><span class="mw-headline" id="Source_Code_Revisions">Source Code Revisions</span></h3>
<ul><li>Initial development: r7613</li>
<li>Known to compile under: r7613</li>
<li>Broken since: --</li></ul>
<p><br />
</p>
<h2><span class="mw-headline" id="Functional_Description">Functional Description</span></h2>
<p>The <i>SerialWidgetADC</i> filter is the key component of the <i>SerialWidget</i> source module, and can acquire signals from a serial-port-equipped embedded system such as an Arduino, Teensy or Pico microcontroller (hereafter referred to as a "widget").
</p><p>This ADC includes all the functionality of the <a href="Contributions%253ASerialInterface.html" title="Contributions:SerialInterface">SerialInterface Extension</a>
(which allows widgets to be used alongside other source acquisition hardware, providing auxiliary input and output).
The difference is that the ADC allows the primary signal to be acquired from the widget as well. This provides cheap platform possibilities for realtime testing during development of BCI2000 setups (as an alternative to the SignalGenerator, SoundcardSource or FilePlayback modules) and also allows BCI2000 to be used as a development tool in microcontroller programming (when you need higher data rates, better timing stability or greater flexibility than the Arduino IDE's Serial Plotter can provide).
</p><p>Developer note: the <i>SerialInterface</i> Extension and the <i>SerialWidgetADC</i> are aware of each other, and the Extension will automatically disable itself in the presence of the ADC, so there is no conflict if the Extension is turned on in CMake during the build.
</p>
<h2><span class="mw-headline" id="Parameters">Parameters</span></h2>
<p>Parameters for handling widgets are described under <a href="Contributions%253ASerialInterface.html" title="Contributions:SerialInterface">Contributions:SerialInterface</a>.
</p><p>As in the <i>SerialInterface</i> Extension,  the <code>--SerialPort</code> parameter must be supplied on the command-line and cannot be changed without relaunching BCI2000.
For example, your <a href="User_Reference%253AOperator_Module_Scripting.html" title="User Reference:Operator Module Scripting">BCI2000 script</a> might contain the line:
</p>
<pre> start executable SerialWidget --local --SerialPort=COM4:baud=9600,dtr=on
</pre>
<p>The same is true of the <code>--PublishCommand</code> parameter, if used. 
</p><p>The one departure from <i>SerialInterface</i> behavior is the handling of custom <code>StartCommand</code> and <code>StopCommand</code> messages. ADCs expect the signal to be delivered between runs as well as during runs.  Therefore, if a <code>StartCommand</code> message is specified, the ADC sends it to the widget as soon as the user presses <b>Set Config</b> (whereas the <i>SerialInterface</i> Extension would wait until the user presses <b>Start</b> or <b>Resume</b>). Similarly, if a <code>StopCommand</code> message is specified, the ADC only sends it immediately prior to disconnecting and reconnecting on subsequent <b>Set Config</b> operations, and/or when BCI2000 quits (whereas the <i>SerialInterface</i> Extension would send it when the user presses <b>Suspend</b>).
</p><p>Additional Parameters may be defined by the widget itself, if you specify a <code>--PublishCommand</code> on the command-line and the widget is programmed to support the specified command, <a href="Contributions%253ASerialInterface.html#Defining_BCI2000_Parameters_and_Events_from_the_Widget" title="Contributions:SerialInterface">as described in the SerialInterface documentation</a>.
</p><p><br />
Parameters common to all source modules are described under <a href="User_Reference%253ADataIOFilter.html" title="User Reference:DataIOFilter">User Reference:DataIOFilter</a>.
<i>SerialWidgetADC</i> adds only one parameter of its own:
</p>
<h3><span class="mw-headline" id="SourceChPins">SourceChPins</span></h3>
<p>This is a list of integer values, one per channel. The widget interprets these numbers when deciding how to acquire signals. The interpretation depends entirely on the way the widget is programmed: the simplest way would be to interpret the numbers as indices of the pins from which signals should be read (for example, as arguments to <code>analogRead()</code> or <code>digitalRead()</code> in the Arduino language). The parameter takes its name from this idea. However, a more-sophisticated widget might be programmed to do its own digital signal processing, and/or to generate artificial signals in response to external sensor inputs, and the relationship between these signals and the <code>SourceChPins</code> values may be arbitrary, as long as the number of channels matches the number of <code>SourceChPins</code> values.
</p>
<h2><span class="mw-headline" id="States">States</span></h2>
<p>The <i>SerialWidgetADC</i> does not define any State Variables or Events of its own, but can create Events as directed by the widget, <a href="Contributions%253ASerialInterface.html#Defining_BCI2000_Parameters_and_Events_from_the_Widget" title="Contributions:SerialInterface">as described in the SerialInterface documentation</a>.
</p><p><br />
</p>
<h2><span class="mw-headline" id="Widget_Programming">Widget Programming</span></h2>
<p>The requirements for widget programming are somewhat more stringent than they were for compatibility with the SerialInterface Extension.
An example SerialWidgetADC-compatible sketch is provided in <a rel="nofollow" class="external text" href="https://bci2000.org/svn/trunk/src/contrib/SignalSource/SerialWidget/ExampleSourceSketch/">the ExampleSourceSketch subdirectory</a> (programs in the Arduino IDE are called "sketches" for some reason). <i>ExampleSourceSketch.ino</i> makes use of the <a rel="nofollow" class="external text" href="https://www.arduino.cc/reference/en/libraries/signalacquisition">SignalAcquisition</a> and <a rel="nofollow" class="external text" href="https://www.arduino.cc/reference/en/libraries/keyhole">Keyhole</a> libraries, which can be installed via the IDE's library manager and which makes it easy for sketches to respond to serial-port commands and to allow their variables to be read and written. This sketch is an expanded version of the <i>TTLExampleSketch.ino</i> provided with the SerialInterface Extension, and it handles TTL input and output in the same way; however, courtesy of the <i>SignalAcquisition</i> library, the sketch also fulfills the following additional requirements for SerialWidgetADC compatibility:
</p>
<ul><li>To enable signal acquisition, the sketch must support the following commands, sent over the serial port (the specific numbers are just examples, but the variable names and syntax must be supported as shown):</li></ul>
<pre>  samplesPerSecond=1000\n
  samplesPerBlock=40\n
  sourcePins="26 27"\n
  
  // NB: in the SignalAcquisition library, the .exposeVariables() method ensures
  //     that your sketch supports these, if called inside a Keyhole::begin() block
</pre>
<ul><li>The widget is responsible for sample timing. When the widget has acquired a complete sample-block (the specified number of signal samples from all the specified pins) it must send a sample-block header, which is either <code>\x01\x00</code> or <code>\x00\x01</code> followed by a line-ending (<code>\n</code> or <code>\r\n</code>). Disregarding the line-ending, the header is actually the 16-bit binary representation of the number 1 (the former version is little-endian, the latter big-endian). Based on the header, the ADC will automatically determine whether the subsequent sample data need to be endian-swapped. The header can be sent easily using the following Arduino code:</li></ul>
<pre>  const uint16_t endianMarker = 1;
  Serial.write( (uint8_t*)&amp;endianMarker, sizeof(endianMarker) );
  Serial.println(); // don't forget the line-ending
  
  // NB: in the SignalAcquisition library, the .acquire() method does this for you
 
</pre>
<ul><li>Immediately after the sample-block header, the widget must send the raw sample data as packed 32-bit floats. The size of this payload is exactly (number of pins)*<code>samplesPerBlock</code>*<code>sizeof(float)</code> bytes.  All the different channels' values for the first sample should be sent in the order specified by <code>sourcePins</code>, then all the channels' values for the second sample, and so on.</li></ul>
<pre>  Serial.write( (uint8_t *)data, numberOfBytes );
  Serial.println(); // a line-ending at this point is optional, but makes debugging easier in the Arduino IDE's Serial Monitor
  Serial.flush();   // important for good timing
  
  // NB: in the SignalAcquisition library, the .acquire() method does this for you
</pre>
<ul><li>Between sample-blocks, the widget may send other messages provided they end with a line-ending (<code>\n</code> or <code>\r\n</code>) and do <b>not</b> begin with <code>\x01\x00</code> or <code>\x00\x01</code>.  This allows it to send the same message types that the SerialInterface Extension allows, which are:
<ul><li>BCI2000 <a href="Programming_Reference%253AEvents.html#Descriptor_Syntax" title="Programming Reference:Events">Event descriptor</a> lines, to mark the timing of arbitrary events: BCI2000 will attempt to interpret any line that does not begin with <code>{</code> as an Event descriptor;</li>
<li>error messages: BCI2000 will issue a fatal error containing the text of any line it receives from the widget if that line begins with <code>{</code> and contains the substring <code>_ERROR_</code> (which is true of any error message sent by the Keyhole library);</li>
<li>any other JSON output: BCI2000 will simply ignore any other line beginning with the <code>{</code> character.</li></ul></li></ul>
<h2><span class="mw-headline" id="Widget_Timing">Widget Timing</span></h2>
<p>The particular implementation in the <i>SignalAcquisition</i> library contains features that will help you verify and debug your widget's timing.
</p>
<ol><li>. In the Serial Monitor of the Arduino IDE, first send the commands to set the acquisition parameters the way you want them. (NB: where you see <code>\n</code> above, do not literally type a backslash followed by an <code>n</code>: the <code>\n</code> stands for the newline character, which the Serial Monitor will append for you when you press return.)</li>
<li>. Then, additionally send <code>commOverheadMicros=1</code> to enable measurement of the serial-port overhead.</li>
<li>. Then send <code>mute=0</code> to begin sending sample-blocks.</li>
<li>. Send <code>mute=1;?</code>  to stop the flow and examine variables.</li>
<li>. Repeatedly alternate <code>mute=0</code> with <code>mute=1;?</code> to take multiple readings.</li></ol>
<p>Verify the following:
</p>
<ol><li>. The <code>idleLoops</code> variable should be reliably greater than 0 when queried with <code>mute=1;?</code> . If it is 0, this indicates that your sketch may be unable to keep up with the desired sample rate. You need to reduce <code>samplesPerSecond</code>.</li>
<li>. The <code>commOverheadMicros</code> variable will now contain a timing measurement indicating the number of microseconds it took to send data over the serial port for the last sample-block. This will be roughly proportional to the number of channels and the number of samples per block. It should not exceed the sample period in microseconds (<code>1e6/samplesPerSecond</code>): if it does, your data will contain readings that were unevenly sampled in time. In that case, you should reduce <code>samplesPerSecond</code>, reduce <code>samplesPerBlock</code>, or reduce the number of channels in <code>sourcePins</code>.</li></ol>
<p>As of version 1.2.0 of the <i>SignalAcquisition</i> library, you can also probe the capabilities of your system by setting <code>samplesPerSecond</code> too high and repeatedly querying the <code>measuredMicrosPerSample</code> variable. This gives you an empirical measurement of the interval between the sample before last and the last one. (You can also use BCI2000 to do something similar: set the <code>SamplingRate</code> parameter too high, and use the timing window to look at the difference between nominal and measured sample-block durations.)
</p>
<h2><span class="mw-headline" id="See_also">See also</span></h2>
<p><a href="User_Reference%253ADataIOFilter.html" title="User Reference:DataIOFilter">User Reference:DataIOFilter</a>, <a href="Programming_Reference%253AGenericADC_Class.html" title="Programming Reference:GenericADC Class">Programming Reference:GenericADC Class</a>, <a href="Contributions%253ASerialInterface.html" title="Contributions:SerialInterface">Contributions:SerialInterface</a>
</p>
<!-- 
NewPP limit report
Cached time: 20241129160345
Cache expiry: 86400
Reduced expiry: false
Complications: [show‐toc]
CPU time usage: 0.026 seconds
Real time usage: 0.030 seconds
Preprocessor visited node count: 48/1000000
Post‐expand include size: 15/2097152 bytes
Template argument size: 0/2097152 bytes
Highest expansion depth: 2/100
Expensive parser function count: 0/100
Unstrip recursion depth: 0/20
Unstrip post‐expand size: 0/5000000 bytes
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%    0.000      1 -total
-->

<!-- Saved in parser cache with key wikidb-bci_:pcache:idhash:2617-0!canonical and timestamp 20241129160345 and revision id 11170.
 -->
</div></div><div class="printfooter">
Retrieved from "<a dir="ltr" href="http://www.bci2000.org/mediawiki/index.php?title=Contributions:SerialWidgetADC&amp;oldid=11170">http://www.bci2000.org/mediawiki/index.php?title=Contributions:SerialWidgetADC&amp;oldid=11170</a>"</div>
 </div>
</body>
</html>